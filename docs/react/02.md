# React성능 최적화

## Diff Algorithm (VDOM)

1. Tree diff 동일레벨(depth) 요소끼리 비교

```jsx
// 전부 교체
<section>
	<div class="content">hello</div>
</section>
<div class="content">hello</div>
```

2. component 비교

```jsx
// 전부 교체
const About = () => <div>About</div>
const Main = () => <div>About</div>

visible ? <About /> : <Main />
```

3. Element Type 비교

```jsx
// 전부 교체
<section>
	<div className="content">hello</div>
</section>
<div>
	<div className="content">hello</div>
</div>

// Element가 동일하니 다음 단계로 pass
<div>
	<section className="content">hello</section>
</div>
<div>
	<div className="content">hello</div>
</div>

```

4. Element Props 비교

```jsx
// Element가 동일할 경우 props 변경된 부분만 교체, 순서 중요하지 않음. 스타일 obj도 마찬가지.
<div style={{width: 40}} id="a">
	<div className="content">hello</div>
</div>
<div style={{width: 70, height: 30}} id="b">
	<div className="content">hello</div>
</div>

// style값이 동일하더라도 변경은 없지만 내부적으로 변화를 비교함
<div style={{width: 40}}>
	<div className="content">hello</div>
</div>
<div style={{width: 40}}>
	<div className="content">hello</div>
</div>
```

5. key(우선순위 제일 높음.)

```jsx
// key설정 하지 않으면 null로 처리.
<div></div>
<div id="a"></div>

// key 다르면 판단하지 않고 교체.
<div key="1">123</div>
<div key="2">123</div>

// key & type(component, element포함)이 동일한 경우 vdom(fiber) 노드를 그대로 사용. (업데이트와 생성의 차이))
<div key="1">123</div>
<p key="1">123</p>

// slibing요소내 key가 서로 다른 경우 순서만 조정(요소 재배치)
<ul>
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li>
</ul>
<ul>
<li key="0">0</li>
<li key="2">2</li>
<li key="1">1</li>
</ul>

!! map에서 index를 넣을 경우 최적화가 어려움.
```
<br/>
<br/>

## React render하는 조건(bailout조건)

- oldProps === newProps
- context 값의 변화가 있는지?
- workInProgress.type === current.type
- 업데이트 EffectTag가 존재한지, 존재하면 이번 priority 업데이트 task에 포함 되는건지 ?

<br/>
<br/>

## 최적화 하는 방법

1. ~~PureComponent,shouldComponentUpdate~~ 
2. React.memo로 캐시(PureComponent로 만들고 싶을때 사용.)

```jsx
// React는 기본적으로 state변경시 해당 컴포넌트 및 자식 컴포넌트 전부 rerender한다.
// bailout로직중 newProps === oldProps 여야만 컴포넌트를 랜딩하지 않는다.
// 하위 컴포넌트에 React.memo 적용시 알고리즘을 실행해서 랭딩한다.
// 자주 변하는 값은 필요없지만 업데이트가 적거나 static한 컴포넌트는 필요하다.

import React, { useState, useMemo } from "react";

const EffectComponent = () => {
  console.log("render effect Component");
  return <>effect Component</>;
};

// const a = <EffectComponent />

// const diff = (prevProps, nextProps) => {
//   console.log(prevProps === nextProps);
//   return prevProps === nextProps;
// }

// const MemoEffectComponent = React.memo(EffectComponent, diff);

const App = () => {
  const [count, setCount] = useState(0); // state또는 context를 건드렸기 때문.
  const onChange = (e) => {
    setCount(count + 1);
  };

  // const b = useMemo(() => <EffectComponent />, [])

  return (
    <>
      <h2>Register</h2>
      <input onChange={onChange} />
      <p>{count}</p>
      <EffectComponent />
      {/* {a} */}
      {/* <MemoEffectComponent /> */}
    </>
  );
};

export default App;
```

3. useMemo, useCallback로 캐시

```jsx
import { useCallback, useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);

  const handleCount = useCallback(() => {
    setCount((count) => count + 1);
  }, []);

  const handleCount2 = useCallback(() => {
    setCount(count + 1);
  }, []);

  return (
    <div className="App">
      <h1>{count}</h1>
      <button onClick={handleCount}>+1</button>
      <button onClick={handleCount2}>+1</button>
    </div>
  );
}
```

4. inlineObject 사용금지

```jsx
// bad
<div style={{width: 200}}></div>
// good
const style = {width:200}
<div>style={style}</style>
```

5. 익명함수 사용금지.

```jsx
// bad
<button onClick={() => {...}}>123</button>

// good
const onClick = () => {...};
<button onClick={onClick}>123</button>
```

6. key활용
7. React.Fragment사용

```jsx
// bad
<div>
  <p>1</p>
  <p>2</p>
</div>

// good
<React.Fragment>
  <p>1</p>
  <p>2</p>
<React.Fragment/>
```

8. lazyload(suspense) with webpack
9. transtion(react18)
10. immer 사용(구조공유)

<br/>
<br/>

## React Design

- 변화(props, state, context)랑 불변을 분리해서 처리.
- 자주 랜더되는 컴포넌트를 찾고 그 parent노드를 찾아 가면서 최적화.

<br/>
<br/>

### 시험단계
**React without memo**

** codesandbox사용시 react memo는 refresh해야 확인가능(livereload로 잘 안됨.)

<br/>
<br/>

### 참고링크
- https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm
